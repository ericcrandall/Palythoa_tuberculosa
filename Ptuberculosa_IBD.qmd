---
title: "Palythoa_IBD"
author: "Eric Crandall"
format: html
editor: source
---

# Isolation By Distance Analysis

Ok, so I am dying to know if these small Nm values between Hawaiian islands are consistent with $\sigma$ estimated with the Rousset/Pinsky IBD method. So I'm going to take the working file of 26,111 SNPs that 'Ale'a used and use that for the IBD analysis

## Load the Data

I'm goingt to use Will Hemstrom's new snpR package for the basic stats. It attaches sample metadata as "facets" to the datasets

```{r}
snps<-read_vcf("/Users/eric/Library/CloudStorage/GoogleDrive-edc5240@psu.edu/My Drive/ptuberculosa/Ptuberculosa_data/mm0.9minq30mac3thin500.recode.vcf")

labels <- read_tsv("/Users/eric/Library/CloudStorage/GoogleDrive-edc5240@psu.edu/My Drive/ptuberculosa/Ptuberculosa_data/labels.txt") %>% arrange(name) %>% mutate(island)

labels <- labels %>% mutate(region = case_when(island %in% c("Big Island","Maui","Molokai","Oahu","Kauai") ~ "High",
                                      .default = "Low"      ))

sample.meta(snps)$pop <- str_replace_all(labels$island," ","_")
sample.meta(snps)$region <- labels$region

```

## Calculate Distance Matrices

### Calculate Fst

Calculate Fst ($\theta_{WC}$) of Weir and Cockerham.

```{r, eval = F}
snps <- calc_pairwise_fst(snps,"pop",fst_over_one_minus_fst = T,verbose=T)
fst <- get.snpR.stats(snps,facets = "pop",stats = "fst")$fst.matrix$pop
#add extra row and column to the data frame, then make it a square matrix
fst <- tibble(fst) %>% add_column(Hawaii = rep(NA,9),.before = 2) %>% add_row(.after = 9)
fst <- as.matrix(fst[,2:11])
#set diagonal equal to zero
diag(fst) <- 0
#make the matrix symmetrical
fst[lower.tri(fst)] <- t(fst)[lower.tri(fst)]
dimnames(fst)[[1]] <- dimnames(fst)[[2]]
#reorder and also drop pioneer banks, which has n = 3
fst <- fst[c(1,6,7,8,3,2,5,9,4),c(1,6,7,8,3,2,5,9,4)]
fst_dist <- as.dist(t(fst), diag = T)
#linearize
fst_dist <- fst_dist/(1-fst_dist)

#fst_pairwise <- get.snpR.stats(snps,facets = "pop",stats = "fst")$weighted.means  %>% 
#                  separate(subfacet,into=c("from","to"), sep = "~")
#fst2 <- fst_pairwise %>% spread(to,weighted_mean_fst, fill = NA)

#write.csv(as.matrix(fst_dist), "IBD/Ptuberculosa_linearizedFst.csv", row.names = F, quote=F)
```

### Calculate Geographic Distance

```{r, eval = F}

localities <- read_csv("./figures/hypotheses_as_graphs/hawaii_vertices.csv") %>% 
                filter(sampled == "black")
gcdists <- as.dist(pointDistance(localities[,c(8,7)], lonlat=T)/1000)
attr(gcdists, "Labels") <- dimnames(fst)[[1]]

#write.csv(as.matrix(gcdists), "IBD/Ptuberculosa_pairwise_great_circle_distances_km.csv", row.names = F, quote=F)

```

### Read Matrices Back In

```{r}
#read in the two distance matrices that were created above
gen.dist.mat <- read.csv(file = "IBD/Ptuberculosa_linearizedFst.csv") 
                               
geo.dist.mat <- read.csv(file = "IBD/Ptuberculosa_pairwise_great_circle_distances_km.csv")

# convert to distance matrix
geo.dist <- as.dist(geo.dist.mat)
gen.dist <- as.dist(gen.dist.mat)

gen.df <- melt(as.matrix(gen.dist), varnames = c("row", "col")) %>% 
                    filter(value %in% as.matrix(gen.fst)[lower.tri(gen.dist)]) %>% 
                    distinct(value, .keep_all=T)
geo.df <- melt(as.matrix(geo.dist), varnames = c("row", "col")) %>% rename(value = distance)

dist.df <- gen.df %>% left_join(geo.df, by=c("row","col")) %>% rename(fst = value.x, distance = value.y)



```

## Create Dispersal Kernel

Following Rousset's [-@roussetGeneticDifferentiationEstimation1997] equation:

$$
\frac{1}{m} = 4D_e\sigma^2
$$

Which [@pinskyMarineDispersalScales2017] re-arranged to give:

$$
\sigma = \sqrt{\frac{1}{4D_em}}
$$

Where $D_e = \frac{N_e}{geog.dist}$ is effective density and m is the slope of the relationship between $\frac{F_{st}}{1 - F_{st}}$ and geographic distance. $\sigma$ is standard deviation of offspring-parent distance. So we need to calculate $N_e$ and $m$.

### Calculate linear model

First to get the slope $m$ we need to make a simple linear model, calculating significance with a Mantel test. Because we have clear evidence of recent genetic exchange between Oahu and Kure (Midway) I'm going to take a closer look at those points with `gghighlight()`.

```{r}
# Oahu has this weird negative slope with distance! Probably due to naval activity
ibd_plot_oahu <- ggplot(dist.df,aes(x=distance,y=fst)) +
                geom_point() + geom_smooth(method=lm) + xlab("Great Circle Distance (km)") + 
                ylab(expression(F["ST"]/1-F["ST"])) + 
                geom_text(label = paste("m =", slope, 
                                        "; Mantel r =", mantelr,
                                        ", p =", pvalue ), 
                          mapping = aes(x = 1000, y = 0.04)) +
            gghighlight(row == "Oahu" | col == "Oahu", keep_scales = T)

ibd_plot_oahu

# Kure has a positive, slightly steeper slope
ibd_plot_kure <- ggplot(dist.df,aes(x=distance,y=fst)) +
                geom_point() + geom_smooth(method=lm) + xlab("Great Circle Distance (km)") + 
                ylab(expression(F["ST"]/1-F["ST"])) + 
                geom_text(label = paste("m =", slope, 
                                        "; Mantel r =", mantelr,
                                        ", p =", pvalue ), 
                          mapping = aes(x = 1000, y = 0.04)) +
            gghighlight(row == "Kure" | col == "Kure", keep_scales = T)

ibd_plot_kure
```

So we'll remove Oahu from these distance matrices

```{r}
# Remove Oahu related distances
dist.df <- dist.df %>% filter(row != "Oahu" & col != "Oahu")
gen.dist.mat <- gen.dist.mat[-4,-4]
geo.dist.mat <- geo.dist.mat[-4,-4]
geo.dist <- as.dist(geo.dist.mat)
gen.dist <- as.dist(gen.dist.mat)

#pull out a few other distances we'll need
neighbordists <- geo.dist.mat[row(geo.dist.mat) == col(geo.dist.mat) + 1]
distfromP1 <- geo.dist.mat[,1]
maxdist <- max(geo.dist.mat)
meandist <- mean(neighbordists)

# mantel test
mantel <- mantel.randtest(gen.dist,geo.dist, nrepet = 10000)

#distances <- tibble(distance=as.vector(geo.dist),fst=as.vector(gen.fst))

ibd_lm <- lm(fst ~ distance , dist.df)

slope <- round(ibd_lm$coefficients[2],7)
mantelr <- round(mantel$obs, 2)
pvalue <- round(mantel$pvalue, 5)


ibd_plot <- ggplot(dist.df,aes(x=distance,y=fst)) +
                geom_point() + geom_smooth(method=lm) + xlab("Great Circle Distance (km)") + 
                ylab(expression(F["ST"]/1-F["ST"])) + 
                geom_text(label = paste("m =", slope, 
                                        "; Mantel r =", mantelr,
                                        ", p =", pvalue ), 
                          mapping = aes(x = 1000, y = 0.04)) 

ibd_plot
#ggsave("IBD/palythoa_IBD_noOahu.pdf", plot=ibd_plot,device="pdf", width=7, height=5,units="in")

```

## Calculate Effective Population Sizes

Going to try snpR's interface to NeEstimator. Alleles with low frequency will tend to bias $N_e$ estimates upward, so a criterion for excluding low-frequency alleles (Pcrit) is implemented. The bias is greatest for low sample sizes which is what we have. For sample sizes < 25, Waples and Do (2010) suggest:

> For S \> 25: choose Pcrit = 0.02.\
> For S \< 25: choose so that 1/(2S) \< Pcrit \< 1/S.

Here are the two bracketing values of Pcrit for each *P. tuberculosa* population:

```{r}
snps@sample.meta %>% count(pop) %>% mutate(pcrit1 = 1/(2*n)) %>% mutate(pcrit2 = 1/(n))
```

Based on this, I am going to use Pcrit of 0.05 for Big Island, and Kauai, 0.125 for Pearl & Hermes, and 0.1 for the rest.

```{r, eval = F}
snps <- calc_ne(snps, facets = "pop", NeEstimator_path = "/Applications/NeEstimator/Ne2-1M", 
              mating = "random", methods = "LD", nsnps = 10000, verbose = T, cleanup = F, pcrit = c(0.05,0.1,0.125))

snps <- calc_ne(snps, NeEstimator_path = "/Applications/NeEstimator/Ne2-1M", 
              mating = "random", methods = "LD", nsnps = 10000, verbose = T, cleanup = F, pcrit = c(0.01,0.02))

snps <- calc_ne(snps, facets = "region", NeEstimator_path = "/Applications/NeEstimator/Ne2-1M", 
              mating = "random", methods = "LD", nsnps = 10000, verbose = T, cleanup = F, pcrit = c(0.02))
```

```{R NeEstimator_output}
Nb_estimates_pops <- read_csv(file = "NeEstimator_pops/Ptuberculosa_ne_outxLD.csv")
Nb_estimates_regions <- read_csv(file = "NeEstimator_regions/Ptuberculosa_outxLD.csv")

# filtering based on rule of thumb from Waples & Do
Nb_estimates_pops_f <- WDFilter(Nb_estimates_pops,3)
Nb_estimates_regions_f <- WDFilter(Nb_estimates_regions,3)


# take the harmonic mean across pops
Nb_hm_pops <- harm_mean(Nb_estimates_pops_f$Ne)
Nb_hm_regions <- harm_mean(Nb_estimates_regions_f$Ne)
# take the median, following Pinsky et al. 2010
Nb_med_pops <- median(Nb_estimates_pops_f$Ne[which(Nb_estimates_pops_f$Ne > 0)])
#results from treating all individuals (juv and adult) as one population (pcrit = 0.02)
Nb_all <- "201.3"
#stick on the distance to next population                                                             
#Nb_estimates_f$DistToNextPop <- c(neighbordists,0)
#Nb_estimates_f$DistFromP1 <- distfromP1


Nb_estimates_pops_f[,c(1:4,8,11,12)]
Nb_estimates_regions_f[,c(1:4,8,11,12)]


#write.csv(Nb_estimates_f,"Nb_estimates_Aclarkii.csv", quote = F, row.names = F)
```
So harmonic mean of Ne across localities gives us a negative number `r Nb_hm_pops`. But sample size isn't large enough for many of those. If we take harmonic mean of Ne calculated across high islands and low islands we get `r Nb_hm_regions`. This is close to 201.3 that we get when we calculate Ne across the whole region. I think I'm going with 225.9 for now.

### Convert Nb to Effective Size

These indivduals were likely sampled across a range of ages, and so we aren't actually getting the effective breeders, but closer to the effective size. 

In addition, because these are RAD markers, with 1,336 SNPS sampled across the genome, some of them are going to be in LD just because they are on the same chromosome. According to @waplesEstimatingContemporaryEffective2016, we can calculate this downward bias even if we don't know which markers are linked to which using:

$$
\frac{\hat{N_e}}{Ne} = 0.098 + 0.219 \times ln(Chr)
$$
... and I have no idea how many chromosomes this species has. Seems like Anthozoans have 14 [*Acropora millepora*](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2009-10-11-r126#:~:text=The%20coral%20A.,%3D%2028%20chromosomes%20%5B7%5D.) or 15 [*Nematostella vectensis* and *Scolanthus callimorphus*](https://www.biorxiv.org/content/biorxiv/early/2020/10/30/2020.10.30.359448.full.pdf) chromosomes. I'll go with 15.



```{r}

oneNchromosome_number <- 15

Ne_adjchr <- neadj_chr(Nb_hm_regions, oneNchromosome_number)[-1]

```

This leaves us with an estimate of $N_e$ = 295.7

We can also consider coalescent effective sizes from migrate. Mean modal $\Theta$ is 0.0061. $N_e = \frac{\Theta}{4\mu}$. So if we consider $\mu$ = 5e-9 [Popovic et al. 2023](https://www.biorxiv.org/content/10.1101/2023.06.28.546961v1) then

```{r}

Ne_coalescent <- 0.0061 / (5e-9 * 4)
  
```

### Calculate sigma

So now let's plug that into the first equation. Binning based on mean distance between sampled populations `r meandist`

```{r sigma}
#effective density for summed Nb
De <- Ne_adjchr/meandist
sigma <- sqrt(1 / (4*De*slope))
#sigmaNeighb <- sqrt(4.1e4/(4*De))
#effective density for median Ne
De_coalescent <- Ne_coalescent/meandist
sigma_coalescent <- sqrt(1 / (4*De_coalescent*slope))

```

So effective density is `r signif(De,4)` individuals per km of barrier reef, and $\sigma$ is `r signif(sigma,4)` km.  Wright's neighborhood size $ NS = 4\pi\sigma^2D_e $ is thus `r signif(4*sigma^2*De,4)`, in a circle of radius `r round(2*sigma,3)` 

For coalescent $N_e$, effective density is `r signif(De_coalescent,4)` individuals per km of barrier reef, and $\sigma$ is `r signif(sigma_coalescent,4)` km.  Wright's neighborhood size $ NS = 4\pi\sigma^2D_e $ is thus `r signif(4*sigma_coalescent^2*De_coalescent,4)`, in a circle of radius `r round(2*sigma_coalescent,3)` 



### Plot Dispersal Kernel

```{r kernelplot}
kernelplot <- ggplot(data.frame(x=c(0,1000)),aes(x)) + 
  stat_function(fun=dexp,args=list(rate=1/sigma),linetype=1,
                color="green", show.legend = T) +
  stat_function(fun=dexp,args=list(rate=1/sigma_coalescent),linetype=1,
                color="blue",show.legend = T) +
  #stat_function(fun=dexp,args=list(rate=1/sigma_all),linetype=2,
  #              aes(color="Slope_All"),show.legend = T) +
  #stat_function(fun=dexp,args=list(rate = 1/3.79), show.legend = T,linetype=3, size=0.2) + 
  #stat_function(fun=dexp,args=list(rate = 1/7.77), show.legend = T,linetype=3, size=0.2) + 
  xlab("Alongshore Distance (km)") + ylab("Dispersal probability density") + ylim(0,0.01)

kernelplot

#ggsave("Aclarkii_SlopeKernels.pdf", plot=kernelplot,device="pdf", 
#       width=5, height=5,units="in")
```

So... effective sizes are really small and I don't think our sample sizes in terms of numbers of individuals are sufficient to give us good estimates. So I'm going to just leave this in the repository, but not report it in the paper.

# Literature Cited